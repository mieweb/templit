{"version":3,"sources":["../src/render.ts","../src/parse.ts"],"sourcesContent":["import Mustache from \"mustache\"\nimport { Liquid } from \"liquidjs\"\nimport Handlebars from \"handlebars\"\nimport { marked } from \"marked\"\nimport { parseTemplate, parseVariables, mergeVariables } from \"./parse\"\nimport type { RenderOptions, RenderResult, TemplateEngine } from \"./types\"\n\n/**\n * Render a template string with the specified engine.\n * Does NOT process frontmatter or markdown â€” use `render()` for the full pipeline.\n */\nexport async function renderWithEngine(\n  content: string,\n  variables: Record<string, unknown>,\n  engine: TemplateEngine,\n): Promise<string> {\n  switch (engine) {\n    case \"liquid\": {\n      const liquid = new Liquid()\n      return liquid.parseAndRender(content, variables)\n    }\n    case \"mustache\":\n      return Mustache.render(content, variables)\n    case \"handlebars\":\n    default: {\n      const compiled = Handlebars.compile(content)\n      return compiled(variables)\n    }\n  }\n}\n\n/**\n * Convert a markdown string to HTML.\n */\nexport async function markdownToHtml(markdown: string): Promise<string> {\n  marked.setOptions({ breaks: true, gfm: true })\n  return marked(markdown)\n}\n\n/**\n * Full rendering pipeline:\n * 1. Parse frontmatter (extract engine + frontmatter variables)\n * 2. Parse YAML variables string\n * 3. Merge variables (frontmatter defaults, explicit overrides)\n * 4. Render through the detected template engine\n * 5. Convert markdown output to HTML\n *\n * @param templateStr - Template string with optional frontmatter\n * @param variables   - YAML string or pre-parsed variables object\n * @param options     - Optional overrides (e.g., force a specific engine)\n */\nexport async function render(\n  templateStr: string,\n  variables: string | Record<string, unknown> = {},\n  options: RenderOptions = {},\n): Promise<RenderResult> {\n  const parsed = parseTemplate(templateStr)\n  const engine = options.engine || parsed.engine\n\n  const explicitVars =\n    typeof variables === \"string\" ? parseVariables(variables) : variables\n\n  const merged = mergeVariables(parsed.frontmatterVars, explicitVars)\n  const raw = await renderWithEngine(parsed.content, merged, engine)\n  const html = await markdownToHtml(raw)\n\n  return { raw, html, engine }\n}\n","import matter from \"gray-matter\"\nimport yaml from \"js-yaml\"\nimport type { ParsedTemplate, TemplateEngine } from \"./types\"\n\nconst VALID_ENGINES: TemplateEngine[] = [\"handlebars\", \"mustache\", \"liquid\"]\n\n/**\n * Parse a template string, extracting frontmatter metadata and variables.\n * The `engine` key in frontmatter controls which rendering engine is used.\n * All other frontmatter keys are treated as template variables.\n */\nexport function parseTemplate(templateStr: string): ParsedTemplate {\n  const { data: frontmatter, content } = matter(templateStr)\n\n  const detectedEngine = VALID_ENGINES.includes(frontmatter.engine)\n    ? (frontmatter.engine as TemplateEngine)\n    : \"handlebars\"\n\n  const { engine: _engine, ...frontmatterVars } = frontmatter\n\n  return { content, engine: detectedEngine, frontmatterVars }\n}\n\n/**\n * Parse a YAML string into a variables object.\n * Returns an empty object for falsy/empty input.\n */\nexport function parseVariables(yamlStr: string): Record<string, unknown> {\n  if (!yamlStr?.trim()) return {}\n  return (yaml.load(yamlStr) as Record<string, unknown>) || {}\n}\n\n/**\n * Merge frontmatter variables with explicit variables.\n * Explicit variables (from the variables bucket) take precedence.\n */\nexport function mergeVariables(\n  frontmatterVars: Record<string, unknown>,\n  explicitVars: Record<string, unknown>,\n): Record<string, unknown> {\n  return { ...frontmatterVars, ...explicitVars }\n}\n"],"mappings":";AAAA,OAAO,cAAc;AACrB,SAAS,cAAc;AACvB,OAAO,gBAAgB;AACvB,SAAS,cAAc;;;ACHvB,OAAO,YAAY;AACnB,OAAO,UAAU;AAGjB,IAAM,gBAAkC,CAAC,cAAc,YAAY,QAAQ;AAOpE,SAAS,cAAc,aAAqC;AACjE,QAAM,EAAE,MAAM,aAAa,QAAQ,IAAI,OAAO,WAAW;AAEzD,QAAM,iBAAiB,cAAc,SAAS,YAAY,MAAM,IAC3D,YAAY,SACb;AAEJ,QAAM,EAAE,QAAQ,SAAS,GAAG,gBAAgB,IAAI;AAEhD,SAAO,EAAE,SAAS,QAAQ,gBAAgB,gBAAgB;AAC5D;AAMO,SAAS,eAAe,SAA0C;AACvE,MAAI,CAAC,SAAS,KAAK,EAAG,QAAO,CAAC;AAC9B,SAAQ,KAAK,KAAK,OAAO,KAAiC,CAAC;AAC7D;AAMO,SAAS,eACd,iBACA,cACyB;AACzB,SAAO,EAAE,GAAG,iBAAiB,GAAG,aAAa;AAC/C;;;AD9BA,eAAsB,iBACpB,SACA,WACA,QACiB;AACjB,UAAQ,QAAQ;AAAA,IACd,KAAK,UAAU;AACb,YAAM,SAAS,IAAI,OAAO;AAC1B,aAAO,OAAO,eAAe,SAAS,SAAS;AAAA,IACjD;AAAA,IACA,KAAK;AACH,aAAO,SAAS,OAAO,SAAS,SAAS;AAAA,IAC3C,KAAK;AAAA,IACL,SAAS;AACP,YAAM,WAAW,WAAW,QAAQ,OAAO;AAC3C,aAAO,SAAS,SAAS;AAAA,IAC3B;AAAA,EACF;AACF;AAKA,eAAsB,eAAe,UAAmC;AACtE,SAAO,WAAW,EAAE,QAAQ,MAAM,KAAK,KAAK,CAAC;AAC7C,SAAO,OAAO,QAAQ;AACxB;AAcA,eAAsB,OACpB,aACA,YAA8C,CAAC,GAC/C,UAAyB,CAAC,GACH;AACvB,QAAM,SAAS,cAAc,WAAW;AACxC,QAAM,SAAS,QAAQ,UAAU,OAAO;AAExC,QAAM,eACJ,OAAO,cAAc,WAAW,eAAe,SAAS,IAAI;AAE9D,QAAM,SAAS,eAAe,OAAO,iBAAiB,YAAY;AAClE,QAAM,MAAM,MAAM,iBAAiB,OAAO,SAAS,QAAQ,MAAM;AACjE,QAAM,OAAO,MAAM,eAAe,GAAG;AAErC,SAAO,EAAE,KAAK,MAAM,OAAO;AAC7B;","names":[]}